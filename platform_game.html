<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f0a1e">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
    <link rel="apple-touch-icon" href="icon-192.png">
    <title>üéÆ PIXEL ADVENTURE üéÆ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            background: #0f0a1e;
            position: fixed;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Force landscape on mobile */
        @media screen and (max-width: 900px) and (orientation: portrait) {
            body::before {
                content: "‚Üª";
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: #0f0a1e;
                color: #fff;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 100px;
                z-index: 99999;
                animation: rotate 2s infinite;
            }
            
            body::after {
                content: "GIRE SEU DISPOSITIVO";
                position: fixed;
                top: 60%;
                left: 50%;
                transform: translateX(-50%);
                color: #fff;
                font-size: 16px;
                z-index: 99999;
                text-align: center;
            }
            
            @keyframes rotate {
                0%, 100% { transform: rotate(0deg); }
                50% { transform: rotate(90deg); }
            }
        }

        /* Mobile controls */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 200px;
            z-index: 500;
            pointer-events: none;
        }

        @media screen and (max-width: 900px) {
            .mobile-controls {
                display: block;
            }
            
            .ui-overlay {
                font-size: 8px;
                top: 5px;
                left: 5px;
            }
            
            .ui-overlay div {
                padding: 5px 8px;
                margin: 3px 0;
            }
        }

        .mobile-btn {
            position: absolute;
            background: rgba(255, 0, 110, 0.4);
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Press Start 2P', cursive;
            pointer-events: auto;
            box-shadow: 0 0 20px rgba(255, 0, 110, 0.6);
            touch-action: none;
            user-select: none;
        }

        .mobile-btn:active {
            background: rgba(255, 0, 110, 0.7);
            box-shadow: 0 0 30px rgba(255, 0, 110, 1);
            transform: scale(0.95);
        }

        .btn-left {
            bottom: 60px;
            left: 20px;
            width: 70px;
            height: 70px;
        }

        .btn-right {
            bottom: 60px;
            left: 110px;
            width: 70px;
            height: 70px;
        }

        .btn-jump {
            bottom: 80px;
            right: 160px;
            width: 80px;
            height: 80px;
            font-size: 16px;
        }

        .btn-shoot {
            bottom: 30px;
            right: 100px;
            width: 60px;
            height: 60px;
            font-size: 14px;
        }

        .btn-dash {
            bottom: 30px;
            right: 20px;
            width: 60px;
            height: 60px;
            font-size: 14px;
        }

        .btn-down {
            bottom: 10px;
            left: 65px;
            width: 60px;
            height: 60px;
            font-size: 20px;
        }

        /* Install button */
        .install-btn {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #00ff88, #00aa55);
            border: 3px solid #fff;
            color: #000;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.5);
        }

        .install-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.7);
        }

        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            -ms-interpolation-mode: nearest-neighbor;
            border: 4px solid #ff006e;
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.5),
                        0 0 60px rgba(138, 43, 226, 0.3),
                        inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .game-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: 
                radial-gradient(circle at 20% 50%, rgba(138, 43, 226, 0.2) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 0, 110, 0.2) 0%, transparent 50%),
                #0f0a1e;
        }

        .ui-overlay {
            position: fixed;
            top: 15px;
            left: 15px;
            color: #fff;
            font-size: 12px;
            text-shadow: 
                2px 2px 0px #000,
                3px 3px 0px rgba(255, 0, 110, 0.5);
            z-index: 100;
            font-family: 'Press Start 2P', cursive;
        }

        .ui-overlay div {
            margin: 10px 0;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.8), rgba(255, 0, 110, 0.8));
            padding: 10px 15px;
            border: 3px solid #fff;
            box-shadow: 0 0 10px rgba(255, 0, 110, 0.8);
            display: inline-block;
        }

        .menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                linear-gradient(135deg, #667eea 0%, #764ba2 100%),
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,.1) 2px, rgba(0,0,0,.1) 4px);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .menu h1 {
            font-size: 48px;
            color: #fff;
            text-shadow: 
                4px 4px 0px #ff006e,
                8px 8px 0px #8b2bca,
                12px 12px 20px rgba(0,0,0,0.8);
            margin-bottom: 60px;
            animation: pulse 2s infinite, glitch 3s infinite;
            font-family: 'Press Start 2P', cursive;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes glitch {
            0%, 90%, 100% { text-shadow: 
                4px 4px 0px #ff006e,
                8px 8px 0px #8b2bca,
                12px 12px 20px rgba(0,0,0,0.8); }
            92% { text-shadow: 
                -4px 4px 0px #00ff88,
                8px -8px 0px #ff006e,
                12px 12px 20px rgba(0,0,0,0.8); }
            94% { text-shadow: 
                4px -4px 0px #8b2bca,
                -8px 8px 0px #00ff88,
                12px 12px 20px rgba(0,0,0,0.8); }
        }

        .menu button {
            font-size: 18px;
            padding: 15px 40px;
            margin: 15px;
            background: linear-gradient(135deg, #ff006e, #8b2bca);
            border: 4px solid #fff;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 
                0 6px 0px #4a0e4e,
                0 10px 20px rgba(0,0,0,0.5);
            font-weight: bold;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 2px 2px 0px #000;
        }

        .menu button:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 9px 0px #4a0e4e,
                0 13px 25px rgba(0,0,0,0.6);
        }

        .menu button:active {
            transform: translateY(3px);
            box-shadow: 
                0 3px 0px #4a0e4e,
                0 5px 10px rgba(0,0,0,0.4);
        }

        .instructions {
            color: white;
            text-align: center;
            margin-top: 30px;
            font-size: 12px;
            line-height: 2;
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border: 3px solid #fff;
            max-width: 600px;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,0,110,.1) 2px, rgba(255,0,110,.1) 4px),
                rgba(0,0,0,0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over h2 {
            font-size: 64px;
            color: #ff006e;
            margin-bottom: 30px;
            font-family: 'Press Start 2P', cursive;
            text-shadow: 
                4px 4px 0px #000,
                8px 8px 0px #8b2bca;
            animation: blink 0.5s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.7; }
        }

        .game-over.victory h2 {
            color: #00ff88;
            text-shadow: 
                4px 4px 0px #000,
                8px 8px 0px #00aa55;
        }

        .hidden {
            display: none !important;
        }

        .heart {
            display: inline-block;
            font-size: 16px;
            margin: 0 3px;
        }
    </style>
</head>
<body>
    <div class="menu" id="mainMenu">
        <h1>PIXEL<br>ADVENTURE</h1>
        <button onclick="startGame()">‚ñ∂ JOGAR</button>
        <div class="instructions">
            <p><strong>CONTROLES</strong></p>
            <p>‚Üê ‚Üí MOVER</p>
            <p>‚Üë ESPA√áO PULAR</p>
            <p>‚Üì AGACHAR</p>
            <p>Z ATIRAR</p>
            <p>X DASH</p>
            <p><br><strong>OBJETIVO</strong></p>
            <p>COLETE MOEDAS<br>DERROTE INIMIGOS<br>CHEGUE AO FINAL</p>
        </div>
    </div>

    <div class="ui-overlay" id="uiOverlay">
        <div>PONTOS <span id="score">0</span></div>
        <div>MOEDAS <span id="coins">0</span></div>
        <div id="lives"></div>
        <div>NIVEL <span id="level">1</span></div>
        <div id="powerups"></div>
    </div>

    <div class="game-over" id="gameOverScreen">
        <h2 id="gameOverText">GAME OVER</h2>
        <div style="color: white; font-size: 18px; margin: 20px; font-family: 'Press Start 2P', cursive;">
            PONTOS <span id="finalScore">0</span>
        </div>
        <button onclick="restartGame()" style="font-size: 16px; padding: 15px 30px; margin: 10px; font-family: 'Press Start 2P', cursive;">CONTINUAR</button>
        <button onclick="showMenu()" style="font-size: 16px; padding: 15px 30px; margin: 10px; font-family: 'Press Start 2P', cursive;">MENU</button>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <button class="install-btn" id="installBtn">üì• INSTALAR</button>

    <div class="mobile-controls" id="mobileControls">
        <div class="mobile-btn btn-left" id="btnLeft">‚Üê</div>
        <div class="mobile-btn btn-right" id="btnRight">‚Üí</div>
        <div class="mobile-btn btn-down" id="btnDown">‚Üì</div>
        <div class="mobile-btn btn-jump" id="btnJump">PULAR</div>
        <div class="mobile-btn btn-shoot" id="btnShoot">Z</div>
        <div class="mobile-btn btn-dash" id="btnDash">X</div>
    </div>

    <script>
        // PWA Installation
        let deferredPrompt;
        const installBtn = document.getElementById('installBtn');

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installBtn.style.display = 'block';
        });

        installBtn.addEventListener('click', async () => {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                deferredPrompt = null;
                installBtn.style.display = 'none';
            }
        });

        window.addEventListener('appinstalled', () => {
            installBtn.style.display = 'none';
        });

        // Register Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {
                console.log('Service Worker registration optional');
            });
        }

        // Mobile controls
        const mobileButtons = {
            left: document.getElementById('btnLeft'),
            right: document.getElementById('btnRight'),
            down: document.getElementById('btnDown'),
            jump: document.getElementById('btnJump'),
            shoot: document.getElementById('btnShoot'),
            dash: document.getElementById('btnDash')
        };

        // Touch event handlers
        function handleTouchStart(key) {
            return (e) => {
                e.preventDefault();
                gameState.keys[key] = true;
                if(key === ' ' || key === 'ArrowUp') {
                    if(gameState.running) {
                        if(player.grounded) {
                            player.velocityY = -player.jumpPower;
                            player.jumping = true;
                            player.doubleJumped = false;
                            createParticles(player.x + player.width/2, player.y + player.height, 5, '#888');
                        } else if(!player.doubleJumped && gameState.powerups.doubleJump) {
                            player.velocityY = -player.jumpPower * 0.8;
                            player.doubleJumped = true;
                            createParticles(player.x + player.width/2, player.y + player.height/2, 8, '#4ecdc4');
                        }
                    }
                } else if(key === 'z') {
                    if(gameState.running) shoot();
                } else if(key === 'x') {
                    if(gameState.running) dash();
                }
            };
        }

        function handleTouchEnd(key) {
            return (e) => {
                e.preventDefault();
                gameState.keys[key] = false;
            };
        }

        // Add touch listeners
        if(mobileButtons.left) {
            mobileButtons.left.addEventListener('touchstart', handleTouchStart('ArrowLeft'));
            mobileButtons.left.addEventListener('touchend', handleTouchEnd('ArrowLeft'));
        }
        if(mobileButtons.right) {
            mobileButtons.right.addEventListener('touchstart', handleTouchStart('ArrowRight'));
            mobileButtons.right.addEventListener('touchend', handleTouchEnd('ArrowRight'));
        }
        if(mobileButtons.down) {
            mobileButtons.down.addEventListener('touchstart', handleTouchStart('ArrowDown'));
            mobileButtons.down.addEventListener('touchend', handleTouchEnd('ArrowDown'));
        }
        if(mobileButtons.jump) {
            mobileButtons.jump.addEventListener('touchstart', handleTouchStart(' '));
            mobileButtons.jump.addEventListener('touchend', handleTouchEnd(' '));
        }
        if(mobileButtons.shoot) {
            mobileButtons.shoot.addEventListener('touchstart', handleTouchStart('z'));
            mobileButtons.shoot.addEventListener('touchend', handleTouchEnd('z'));
        }
        if(mobileButtons.dash) {
            mobileButtons.dash.addEventListener('touchstart', handleTouchStart('x'));
            mobileButtons.dash.addEventListener('touchend', handleTouchEnd('x'));
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas sizing
        function resizeCanvas() {
            const container = document.querySelector('.game-container');
            const maxWidth = window.innerWidth;
            const maxHeight = window.innerHeight;
            const aspectRatio = 16 / 9;
            
            let width = maxWidth;
            let height = width / aspectRatio;
            
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }

        canvas.width = 960;
        canvas.height = 540;
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', resizeCanvas);
        
        // Pixel perfect rendering
        ctx.imageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.mozImageSmoothingEnabled = false;

        // Pixel Art Drawing Functions
        function drawPixel(x, y, size, color) {
            ctx.fillStyle = color;
            ctx.fillRect(Math.floor(x), Math.floor(y), size, size);
        }

        function drawPlayerSprite(x, y, direction, frame, crouching) {
            const px = Math.floor(x);
            const py = Math.floor(y);
            const s = 4; // pixel size
            
            // Helper function to draw pixel with direction
            function drawDirectionalPixel(xPos, yPos, size, color) {
                if(direction > 0) {
                    drawPixel(px + xPos * s, py + yPos * s, size, color);
                } else {
                    // Mirror for left direction
                    drawPixel(px + (7 - xPos) * s, py + yPos * s, size, color);
                }
            }
            
            if(crouching) {
                // Crouching sprite
                const colors = {
                    skin: '#ffcc99',
                    shirt: '#ff006e',
                    pants: '#0066ff',
                    shoes: '#333',
                    eyes: '#000',
                    outline: '#000'
                };
                
                // Outline
                [[1,2],[2,2],[3,2],[4,2],[5,2],[6,2],
                 [0,3],[7,3],[0,4],[7,4],[0,5],[7,5],
                 [1,6],[2,6],[3,6],[4,6],[5,6],[6,6]].forEach(p => {
                    drawDirectionalPixel(p[0], p[1], s, colors.outline);
                });
                
                // Face
                [[1,3],[2,3],[3,3],[4,3],[5,3],[6,3]].forEach(p => {
                    drawDirectionalPixel(p[0], p[1], s, colors.skin);
                });
                
                // Eyes (adjusted for direction)
                if(direction > 0) {
                    drawDirectionalPixel(2, 3, s, colors.eyes);
                    drawDirectionalPixel(4, 3, s, colors.eyes);
                } else {
                    drawDirectionalPixel(3, 3, s, colors.eyes);
                    drawDirectionalPixel(5, 3, s, colors.eyes);
                }
                
                // Body
                [[1,4],[2,4],[3,4],[4,4],[5,4],[6,4],
                 [1,5],[2,5],[3,5],[4,5],[5,5],[6,5]].forEach(p => {
                    drawDirectionalPixel(p[0], p[1], s, colors.shirt);
                });
                
            } else {
                // Standing/Running sprite
                const colors = {
                    skin: '#ffcc99',
                    hair: '#4a2511',
                    shirt: '#ff006e',
                    pants: '#0066ff',
                    shoes: '#333',
                    eyes: '#000',
                    outline: '#000'
                };
                
                const walkFrame = Math.floor(frame) % 4;
                
                // Outline
                [[2,0],[3,0],[4,0],[5,0],
                 [1,1],[6,1],[1,2],[6,2],
                 [1,3],[6,3],[1,4],[6,4],
                 [0,5],[2,5],[5,5],[7,5],
                 [0,6],[2,6],[5,6],[7,6],
                 [1,7],[2,7],[5,7],[6,7]].forEach(p => {
                    drawDirectionalPixel(p[0], p[1], s, colors.outline);
                });
                
                // Hair
                [[2,1],[3,1],[4,1],[5,1]].forEach(p => {
                    drawDirectionalPixel(p[0], p[1], s, colors.hair);
                });
                
                // Face
                [[2,2],[3,2],[4,2],[5,2],
                 [2,3],[3,3],[4,3],[5,3]].forEach(p => {
                    drawDirectionalPixel(p[0], p[1], s, colors.skin);
                });
                
                // Eyes (properly positioned for each direction)
                if(direction > 0) {
                    drawDirectionalPixel(3, 2, s, colors.eyes);
                    drawDirectionalPixel(5, 2, s, colors.eyes);
                } else {
                    drawDirectionalPixel(2, 2, s, colors.eyes);
                    drawDirectionalPixel(4, 2, s, colors.eyes);
                }
                
                // Smile
                [[3,3],[4,3]].forEach(p => {
                    drawDirectionalPixel(p[0], p[1], s, '#ff6b9d');
                });
                
                // Shirt
                [[2,4],[3,4],[4,4],[5,4],
                 [1,5],[2,5],[3,5],[4,5],[5,5],[6,5]].forEach(p => {
                    drawDirectionalPixel(p[0], p[1], s, colors.shirt);
                });
                
                // Pants & Legs
                if(walkFrame === 0 || walkFrame === 2) {
                    [[1,6],[2,6],[3,6],[4,6],[5,6],[6,6]].forEach(p => {
                        drawDirectionalPixel(p[0], p[1], s, colors.pants);
                    });
                    [[2,7],[3,7],[4,7],[5,7]].forEach(p => {
                        drawDirectionalPixel(p[0], p[1], s, colors.shoes);
                    });
                } else {
                    // Walking animation
                    if(walkFrame === 1) {
                        [[1,6],[2,6]].forEach(p => {
                            drawDirectionalPixel(p[0], p[1], s, colors.pants);
                        });
                        [[4,6],[5,6],[6,6]].forEach(p => {
                            drawDirectionalPixel(p[0], p[1], s, colors.pants);
                        });
                        [[1,7],[2,7]].forEach(p => {
                            drawDirectionalPixel(p[0], p[1], s, colors.shoes);
                        });
                        [[5,7],[6,7]].forEach(p => {
                            drawDirectionalPixel(p[0], p[1], s, colors.shoes);
                        });
                    } else {
                        [[1,6],[2,6],[3,6]].forEach(p => {
                            drawDirectionalPixel(p[0], p[1], s, colors.pants);
                        });
                        [[5,6],[6,6]].forEach(p => {
                            drawDirectionalPixel(p[0], p[1], s, colors.pants);
                        });
                        [[1,7],[2,7]].forEach(p => {
                            drawDirectionalPixel(p[0], p[1], s, colors.shoes);
                        });
                        [[5,7],[6,7]].forEach(p => {
                            drawDirectionalPixel(p[0], p[1], s, colors.shoes);
                        });
                    }
                }
            }
        }

        function drawEnemyWalker(x, y, frame) {
            const px = Math.floor(x);
            const py = Math.floor(y);
            const s = 3;
            const walkFrame = Math.floor(frame) % 2;
            
            const colors = {
                body: '#ff4757',
                dark: '#c0392b',
                eyes: '#fff',
                pupil: '#000',
                outline: '#8b1e3f'
            };
            
            // Outline
            [[1,1],[2,1],[3,1],[4,1],[5,1],[6,1],
             [0,2],[7,2],[0,3],[7,3],[0,4],[7,4],
             [1,5],[2,5],[5,5],[6,5]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.outline);
            });
            
            // Body
            [[1,2],[2,2],[3,2],[4,2],[5,2],[6,2],
             [1,3],[2,3],[3,3],[4,3],[5,3],[6,3],
             [1,4],[2,4],[3,4],[4,4],[5,4],[6,4]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.body);
            });
            
            // Shading
            [[5,2],[6,2],[5,3],[6,3]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.dark);
            });
            
            // Eyes
            [[2,2],[5,2]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.eyes);
            });
            [[2,3],[5,3]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.pupil);
            });
            
            // Legs (animated)
            if(walkFrame === 0) {
                [[2,5],[3,5],[4,5],[5,5]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.body);
                });
            } else {
                [[1,5],[2,5],[5,5],[6,5]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.body);
                });
            }
        }

        function drawEnemyFlying(x, y, frame) {
            const px = Math.floor(x);
            const py = Math.floor(y);
            const s = 3;
            const wingFrame = Math.floor(frame * 2) % 2;
            
            const colors = {
                body: '#9b59b6',
                dark: '#6c3483',
                eyes: '#f39c12',
                wing: '#8e44ad',
                outline: '#4a235a'
            };
            
            // Wings
            if(wingFrame === 0) {
                [[-2,1],[-1,1],[-1,2],
                 [8,1],[9,1],[8,2]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.wing);
                });
            } else {
                [[-2,2],[-1,2],[-1,3],
                 [8,2],[9,2],[8,3]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.wing);
                });
            }
            
            // Outline
            [[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],
             [0,1],[7,1],[0,2],[7,2],[0,3],[7,3],
             [1,4],[2,4],[3,4],[4,4],[5,4],[6,4]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.outline);
            });
            
            // Body
            [[1,1],[2,1],[3,1],[4,1],[5,1],[6,1],
             [1,2],[2,2],[3,2],[4,2],[5,2],[6,2],
             [1,3],[2,3],[3,3],[4,3],[5,3],[6,3]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.body);
            });
            
            // Shading
            [[4,1],[5,1],[6,1],
             [5,2],[6,2]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.dark);
            });
            
            // Eyes
            [[2,1],[5,1]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.eyes);
            });
        }

        function drawBoss(x, y, frame) {
            const px = Math.floor(x);
            const py = Math.floor(y);
            const s = 5;
            
            const colors = {
                body: '#e74c3c',
                dark: '#c0392b',
                darker: '#8b1e3f',
                eyes: '#f39c12',
                eyeGlow: '#f1c40f',
                teeth: '#fff',
                outline: '#000'
            };
            
            // Horns
            [[1,0],[2,0],[14,0],[15,0],
             [0,1],[1,1],[15,1],[16,1]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.darker);
            });
            
            // Head outline
            for(let i = 2; i < 14; i++) {
                drawPixel(px + i*s, py + 0, s, colors.outline);
            }
            for(let i = 0; i < 17; i++) {
                drawPixel(px + i*s, py + 6*s, s, colors.outline);
            }
            
            // Face
            for(let row = 1; row < 6; row++) {
                for(let col = 2; col < 14; col++) {
                    drawPixel(px + col*s, py + row*s, s, colors.body);
                }
            }
            
            // Shading
            for(let row = 1; row < 6; row++) {
                for(let col = 10; col < 14; col++) {
                    drawPixel(px + col*s, py + row*s, s, colors.dark);
                }
            }
            
            // Eyes with glow
            [[3,2],[4,2],[10,2],[11,2]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.eyeGlow);
            });
            [[4,2],[11,2]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.eyes);
            });
            
            // Angry eyebrows
            [[3,1],[4,1],[5,1],[9,1],[10,1],[11,1]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.darker);
            });
            
            // Mouth/Teeth
            [[4,4],[5,4],[6,4],[7,4],[8,4],[9,4],[10,4]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.outline);
            });
            [[5,5],[7,5],[9,5]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.teeth);
            });
            
            // Body
            for(let row = 7; row < 14; row++) {
                for(let col = 3; col < 13; col++) {
                    drawPixel(px + col*s, py + row*s, s, colors.body);
                }
            }
            
            // Body shading
            for(let row = 7; row < 14; row++) {
                for(let col = 9; col < 13; col++) {
                    drawPixel(px + col*s, py + row*s, s, colors.dark);
                }
            }
            
            // Arms
            [[1,8],[2,8],[1,9],[2,9],
             [13,8],[14,8],[13,9],[14,9]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.body);
            });
            
            // Legs
            [[4,14],[5,14],[6,14],
             [9,14],[10,14],[11,14]].forEach(p => {
                drawPixel(px + p[0]*s, py + p[1]*s, s, colors.dark);
            });
        }

        function drawCoin(x, y, frame) {
            const px = Math.floor(x);
            const py = Math.floor(y);
            const s = 3;
            const rotation = Math.floor(frame * 4) % 8;
            
            const colors = {
                gold: '#ffd700',
                goldDark: '#daa520',
                goldLight: '#ffed4e',
                outline: '#b8860b'
            };
            
            if(rotation < 2 || rotation > 5) {
                // Full coin
                [[1,0],[2,0],[3,0],[4,0],
                 [0,1],[5,1],[0,2],[5,2],[0,3],[5,3],
                 [1,4],[2,4],[3,4],[4,4]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.outline);
                });
                
                [[1,1],[2,1],[3,1],[4,1],
                 [1,2],[2,2],[3,2],[4,2],
                 [1,3],[2,3],[3,3],[4,3]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.gold);
                });
                
                [[1,1],[2,1]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.goldLight);
                });
                
                [[3,2],[4,2],[3,3],[4,3]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.goldDark);
                });
            } else {
                // Thin coin
                [[2,0],[3,0],
                 [1,1],[4,1],[1,2],[4,2],[1,3],[4,3],
                 [2,4],[3,4]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.outline);
                });
                
                [[2,1],[3,1],[2,2],[3,2],[2,3],[3,3]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, colors.gold);
                });
            }
        }

        function drawGrassPlatform(x, y, width, height) {
            const s = 8;
            const colors = {
                grass: '#4ecb5c',
                grassDark: '#2e7d32',
                dirt: '#8b4513',
                dirtDark: '#654321'
            };
            
            // Grass top
            for(let i = 0; i < width; i += s) {
                drawPixel(x + i, y, s, colors.grass);
                if(i % 16 === 0) {
                    drawPixel(x + i, y - s, s, colors.grassDark);
                    drawPixel(x + i + s, y - s, s, colors.grass);
                }
            }
            
            // Dirt
            for(let j = s; j < height; j += s) {
                for(let i = 0; i < width; i += s) {
                    const isDark = (i + j) % 16 === 0;
                    drawPixel(x + i, y + j, s, isDark ? colors.dirtDark : colors.dirt);
                }
            }
        }

        function drawStonePlatform(x, y, width, height) {
            const s = 8;
            const colors = {
                stone: '#7f8c8d',
                stoneDark: '#5a6266',
                stoneLight: '#95a5a6'
            };
            
            // Stone blocks
            for(let j = 0; j < height; j += s*2) {
                for(let i = 0; i < width; i += s*2) {
                    const offset = (j / (s*2)) % 2 === 0 ? 0 : s;
                    drawPixel(x + i + offset, y + j, s*2, colors.stone);
                    drawPixel(x + i + offset, y + j, s, colors.stoneLight);
                    drawPixel(x + i + offset + s, y + j + s, s, colors.stoneDark);
                }
            }
        }

        function drawPowerup(x, y, type, frame) {
            const px = Math.floor(x);
            const py = Math.floor(y);
            const s = 4;
            const float = Math.sin(frame) * 3;
            
            const colors = {
                box: '#ff00ff',
                boxDark: '#cc00cc',
                symbol: '#fff',
                outline: '#660066'
            };
            
            // Box outline
            for(let i = 0; i < 6; i++) {
                drawPixel(px + i*s, py + float, s, colors.outline);
                drawPixel(px + i*s, py + float + 5*s, s, colors.outline);
            }
            for(let i = 1; i < 5; i++) {
                drawPixel(px, py + float + i*s, s, colors.outline);
                drawPixel(px + 5*s, py + float + i*s, s, colors.outline);
            }
            
            // Box fill
            for(let j = 1; j < 5; j++) {
                for(let i = 1; i < 5; i++) {
                    drawPixel(px + i*s, py + float + j*s, s, 
                             (i + j) % 2 === 0 ? colors.box : colors.boxDark);
                }
            }
            
            // Symbol
            if(type === 'doubleJump') {
                [[2,1],[2,2],[1,2],[3,2],
                 [2,3],[2,4],[1,4],[3,4]].forEach(p => {
                    drawPixel(px + p[0]*s, py + float + p[1]*s, s, colors.symbol);
                });
            } else if(type === 'shield') {
                [[2,1],[1,2],[3,2],[1,3],[2,3],[3,3],[2,4]].forEach(p => {
                    drawPixel(px + p[0]*s, py + float + p[1]*s, s, colors.symbol);
                });
            } else if(type === 'speedBoost') {
                [[3,2],[2,2],[2,3],[1,3],[2,3],[3,3],[2,4]].forEach(p => {
                    drawPixel(px + p[0]*s, py + float + p[1]*s, s, colors.symbol);
                });
            } else if(type === 'fireRate') {
                [[2,1],[2,2],[1,2],[3,2],[2,3],[1,3],[3,3]].forEach(p => {
                    drawPixel(px + p[0]*s, py + float + p[1]*s, s, colors.symbol);
                });
            }
        }

        function drawProjectile(x, y, isEnemy) {
            const px = Math.floor(x);
            const py = Math.floor(y);
            const s = 2;
            
            if(isEnemy) {
                [[0,1],[1,1],[2,1],
                 [1,0],[1,2]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, '#ff0000');
                });
                drawPixel(px + s, py + s, s, '#ff6b6b');
            } else {
                [[1,0],[0,1],[1,1],[2,1],[1,2]].forEach(p => {
                    drawPixel(px + p[0]*s, py + p[1]*s, s, '#ffff00');
                });
                drawPixel(px + s, py + s, s, '#ffed4e');
            }
        }

        function drawParticle(x, y, size, color) {
            const s = Math.max(2, Math.floor(size));
            drawPixel(Math.floor(x), Math.floor(y), s, color);
        }

        function drawStar(x, y, size) {
            const px = Math.floor(x);
            const py = Math.floor(y);
            const s = 2;
            
            drawPixel(px, py, s, '#ffffff');
            if(size > 1) {
                drawPixel(px - s, py, s, '#cccccc');
                drawPixel(px + s, py, s, '#cccccc');
                drawPixel(px, py - s, s, '#cccccc');
                drawPixel(px, py + s, s, '#cccccc');
            }
        }

        // Game state
        let gameState = {
            running: false,
            score: 0,
            coins: 0,
            lives: 3,
            currentLevel: 1,
            keys: {},
            particles: [],
            powerups: {
                doubleJump: false,
                shield: false,
                speedBoost: false,
                fireRate: 1
            }
        };

        // Player
        const player = {
            x: 100,
            y: 400,
            width: 32,
            height: 32,
            velocityX: 0,
            velocityY: 0,
            speed: 5,
            jumpPower: 12,
            grounded: false,
            direction: 1,
            jumping: false,
            doubleJumped: false,
            crouching: false,
            invincible: false,
            canShoot: true,
            dashCooldown: 0,
            animation: 0
        };

        // Camera
        const camera = {
            x: 0,
            y: 0
        };

        // Game objects
        let platforms = [];
        let enemies = [];
        let coins = [];
        let powerups = [];
        let projectiles = [];
        let checkpoints = [];
        let boss = null;

        // Level data
        const levels = [
            {
                name: "Green Hills",
                background: '#87CEEB',
                platforms: [
                    {x: 0, y: 550, width: 3000, height: 50, type: 'grass'},
                    {x: 300, y: 450, width: 150, height: 20, type: 'grass'},
                    {x: 550, y: 380, width: 150, height: 20, type: 'grass'},
                    {x: 800, y: 320, width: 200, height: 20, type: 'grass'},
                    {x: 1100, y: 380, width: 150, height: 20, type: 'grass'},
                    {x: 1350, y: 450, width: 150, height: 20, type: 'grass'},
                    {x: 1600, y: 380, width: 200, height: 20, type: 'grass', moving: true, moveRange: 150},
                    {x: 1950, y: 320, width: 150, height: 20, type: 'grass'},
                    {x: 2200, y: 250, width: 200, height: 20, type: 'grass'},
                    {x: 2500, y: 320, width: 150, height: 20, type: 'grass'},
                ],
                enemies: [
                    {x: 400, y: 420, type: 'walker'},
                    {x: 900, y: 290, type: 'walker'},
                    {x: 1200, y: 350, type: 'flying'},
                    {x: 1700, y: 200, type: 'flying'},
                    {x: 2300, y: 220, type: 'walker'},
                ],
                coins: generateCoins([
                    {x: 350, y: 400},
                    {x: 600, y: 330},
                    {x: 850, y: 270},
                    {x: 1150, y: 330},
                    {x: 1650, y: 330},
                    {x: 2000, y: 270},
                    {x: 2250, y: 200},
                ]),
                powerups: [
                    {x: 600, y: 340, type: 'doubleJump'},
                    {x: 2250, y: 210, type: 'shield'},
                ],
                checkpoint: {x: 1500, y: 480},
                goal: {x: 2700, y: 450}
            },
            {
                name: "Lava Caves",
                background: '#2d1810',
                platforms: [
                    {x: 0, y: 550, width: 400, height: 50, type: 'stone'},
                    {x: 500, y: 550, width: 200, height: 50, type: 'stone'},
                    {x: 800, y: 550, width: 300, height: 50, type: 'stone'},
                    {x: 450, y: 450, width: 120, height: 20, type: 'stone'},
                    {x: 650, y: 380, width: 120, height: 20, type: 'stone'},
                    {x: 850, y: 320, width: 120, height: 20, type: 'stone'},
                    {x: 1050, y: 380, width: 200, height: 20, type: 'stone'},
                    {x: 1350, y: 320, width: 150, height: 20, type: 'stone', breakable: true},
                    {x: 1600, y: 400, width: 200, height: 20, type: 'stone'},
                    {x: 1900, y: 350, width: 150, height: 20, type: 'stone', moving: true, moveRange: 200},
                    {x: 2200, y: 280, width: 200, height: 20, type: 'stone'},
                    {x: 2500, y: 380, width: 400, height: 20, type: 'stone'},
                ],
                enemies: [
                    {x: 500, y: 520, type: 'walker'},
                    {x: 900, y: 520, type: 'walker'},
                    {x: 750, y: 250, type: 'flying'},
                    {x: 1150, y: 350, type: 'walker'},
                    {x: 1500, y: 200, type: 'flying'},
                    {x: 2000, y: 250, type: 'flying'},
                    {x: 2600, y: 350, type: 'walker'},
                ],
                hazards: [
                    {x: 400, y: 560, width: 100, type: 'lava'},
                    {x: 700, y: 560, width: 100, type: 'lava'},
                    {x: 1200, y: 400, width: 80, type: 'spikes'},
                    {x: 2100, y: 300, width: 100, type: 'spikes'},
                ],
                coins: generateCoins([
                    {x: 500, y: 400},
                    {x: 700, y: 330},
                    {x: 900, y: 270},
                    {x: 1400, y: 270},
                    {x: 1950, y: 300},
                    {x: 2250, y: 230},
                ]),
                powerups: [
                    {x: 900, y: 280, type: 'speedBoost'},
                    {x: 2250, y: 240, type: 'fireRate'},
                ],
                checkpoint: {x: 1400, y: 250},
                goal: {x: 2800, y: 310}
            },
            {
                name: "Boss Battle",
                background: '#1a0a0a',
                platforms: [
                    {x: 0, y: 550, width: 2000, height: 50, type: 'stone'},
                    {x: 200, y: 400, width: 150, height: 20, type: 'stone'},
                    {x: 600, y: 350, width: 150, height: 20, type: 'stone'},
                    {x: 1000, y: 400, width: 150, height: 20, type: 'stone'},
                    {x: 1400, y: 350, width: 150, height: 20, type: 'stone'},
                ],
                boss: {
                    x: 1500,
                    y: 350,
                    width: 80,
                    height: 80,
                    health: 20,
                    maxHealth: 20,
                    speed: 2,
                    attackCooldown: 0
                },
                coins: generateCoins([
                    {x: 250, y: 350},
                    {x: 650, y: 300},
                    {x: 1050, y: 350},
                    {x: 1450, y: 300},
                ]),
                powerups: [
                    {x: 100, y: 480, type: 'shield'},
                    {x: 1800, y: 480, type: 'fireRate'},
                ],
            }
        ];

        function generateCoins(positions) {
            const coins = [];
            positions.forEach(pos => {
                for(let i = 0; i < 3; i++) {
                    coins.push({
                        x: pos.x + (i * 30),
                        y: pos.y,
                        width: 20,
                        height: 20,
                        collected: false,
                        animation: Math.random() * Math.PI * 2
                    });
                }
            });
            return coins;
        }

        function loadLevel(levelIndex) {
            const level = levels[levelIndex - 1];
            platforms = JSON.parse(JSON.stringify(level.platforms));
            enemies = level.enemies ? JSON.parse(JSON.stringify(level.enemies)) : [];
            coins = level.coins ? JSON.parse(JSON.stringify(level.coins)) : [];
            powerups = level.powerups ? JSON.parse(JSON.stringify(level.powerups)) : [];
            checkpoints = level.checkpoint ? [level.checkpoint] : [];
            boss = level.boss ? JSON.parse(JSON.stringify(level.boss)) : null;
            projectiles = [];
            
            // Initialize enemies
            enemies.forEach(enemy => {
                enemy.width = 30;
                enemy.height = 30;
                enemy.velocityX = enemy.type === 'walker' ? 2 : 0;
                enemy.velocityY = enemy.type === 'flying' ? 1 : 0;
                enemy.health = 1;
                enemy.direction = -1;
            });

            // Reset player position
            player.x = 100;
            player.y = 400;
            player.velocityX = 0;
            player.velocityY = 0;
            camera.x = 0;
        }

        function startGame() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('uiOverlay').classList.remove('hidden');
            gameState.running = true;
            gameState.score = 0;
            gameState.coins = 0;
            gameState.lives = 3;
            gameState.currentLevel = 1;
            gameState.powerups = {
                doubleJump: false,
                shield: false,
                speedBoost: false,
                fireRate: 1
            };
            loadLevel(1);
            updateUI();
            gameLoop();
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            startGame();
        }

        function showMenu() {
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('uiOverlay').classList.add('hidden');
            gameState.running = false;
        }

        function gameOver(victory = false) {
            gameState.running = false;
            const screen = document.getElementById('gameOverScreen');
            const text = document.getElementById('gameOverText');
            
            if(victory) {
                text.textContent = 'üéâ VIT√ìRIA! üéâ';
                screen.classList.add('victory');
            } else {
                text.textContent = 'üíÄ GAME OVER üíÄ';
                screen.classList.remove('victory');
            }
            
            document.getElementById('finalScore').textContent = gameState.score;
            screen.style.display = 'flex';
        }

        function nextLevel() {
            gameState.currentLevel++;
            if(gameState.currentLevel > levels.length) {
                gameOver(true);
            } else {
                loadLevel(gameState.currentLevel);
                updateUI();
            }
        }

        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('coins').textContent = gameState.coins;
            document.getElementById('level').textContent = gameState.currentLevel;
            
            let livesHTML = '';
            for(let i = 0; i < gameState.lives; i++) {
                livesHTML += '<span class="heart">‚ù§Ô∏è</span>';
            }
            document.getElementById('lives').innerHTML = livesHTML;

            let powerupsHTML = '';
            if(gameState.powerups.doubleJump) powerupsHTML += '‚¨ÜÔ∏è ';
            if(gameState.powerups.shield) powerupsHTML += 'üõ°Ô∏è ';
            if(gameState.powerups.speedBoost) powerupsHTML += '‚ö° ';
            if(gameState.powerups.fireRate > 1) powerupsHTML += 'üî• ';
            document.getElementById('powerups').innerHTML = powerupsHTML;
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key] = true;
            
            if(gameState.running) {
                if(e.key === ' ' || e.key === 'ArrowUp') {
                    if(player.grounded) {
                        player.velocityY = -player.jumpPower;
                        player.jumping = true;
                        player.doubleJumped = false;
                        createParticles(player.x + player.width/2, player.y + player.height, 5, '#888');
                    } else if(!player.doubleJumped && gameState.powerups.doubleJump) {
                        player.velocityY = -player.jumpPower * 0.8;
                        player.doubleJumped = true;
                        createParticles(player.x + player.width/2, player.y + player.height/2, 8, '#4ecdc4');
                    }
                    e.preventDefault();
                }
                
                if(e.key === 'z' || e.key === 'Z') {
                    shoot();
                }
                
                if(e.key === 'x' || e.key === 'X') {
                    dash();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key] = false;
        });

        function shoot() {
            if(!player.canShoot) return;
            
            projectiles.push({
                x: player.x + (player.direction > 0 ? player.width : 0),
                y: player.y + player.height/2,
                width: 10,
                height: 6,
                velocityX: player.direction * 10,
                damage: 1
            });
            
            player.canShoot = false;
            const cooldown = 300 / gameState.powerups.fireRate;
            setTimeout(() => player.canShoot = true, cooldown);
            
            createParticles(player.x + player.width/2, player.y + player.height/2, 3, '#ffff00');
        }

        function dash() {
            if(player.dashCooldown > 0) return;
            
            player.velocityX = player.direction * 15;
            player.dashCooldown = 60;
            player.invincible = true;
            
            setTimeout(() => player.invincible = false, 200);
            
            createParticles(player.x + player.width/2, player.y + player.height/2, 10, '#00ffff');
        }

        function createParticles(x, y, count, color) {
            for(let i = 0; i < count; i++) {
                gameState.particles.push({
                    x: x,
                    y: y,
                    velocityX: (Math.random() - 0.5) * 6,
                    velocityY: (Math.random() - 0.5) * 6,
                    size: Math.random() * 4 + 2,
                    color: color,
                    life: 30
                });
            }
        }

        function update() {
            if(!gameState.running) return;

            // Update player
            player.animation += 0.1;
            
            if(gameState.keys['ArrowLeft']) {
                const speed = player.speed * (gameState.powerups.speedBoost ? 1.5 : 1);
                player.velocityX = -speed;
                player.direction = -1;
            } else if(gameState.keys['ArrowRight']) {
                const speed = player.speed * (gameState.powerups.speedBoost ? 1.5 : 1);
                player.velocityX = speed;
                player.direction = 1;
            } else {
                player.velocityX *= 0.8;
            }

            player.crouching = gameState.keys['ArrowDown'] && player.grounded;
            
            if(player.dashCooldown > 0) player.dashCooldown--;

            // Gravity
            player.velocityY += 0.6;
            if(player.velocityY > 15) player.velocityY = 15;

            player.x += player.velocityX;
            player.y += player.velocityY;

            // Platform collision
            player.grounded = false;
            platforms.forEach(platform => {
                // Moving platforms
                if(platform.moving) {
                    if(!platform.moveOffset) platform.moveOffset = 0;
                    if(!platform.moveDirection) platform.moveDirection = 1;
                    
                    platform.moveOffset += platform.moveDirection * 2;
                    if(Math.abs(platform.moveOffset) > platform.moveRange) {
                        platform.moveDirection *= -1;
                    }
                    platform.x += platform.moveDirection * 2;
                }

                if(player.x < platform.x + platform.width &&
                   player.x + player.width > platform.x &&
                   player.y < platform.y + platform.height &&
                   player.y + player.height > platform.y) {
                    
                    // Top collision
                    if(player.velocityY > 0 && player.y + player.height - player.velocityY <= platform.y) {
                        player.y = platform.y - player.height;
                        player.velocityY = 0;
                        player.grounded = true;
                        player.jumping = false;
                        
                        // Breakable platforms
                        if(platform.breakable && !platform.breaking) {
                            platform.breaking = true;
                            setTimeout(() => {
                                platforms = platforms.filter(p => p !== platform);
                            }, 500);
                        }
                    }
                    // Bottom collision
                    else if(player.velocityY < 0) {
                        player.y = platform.y + platform.height;
                        player.velocityY = 0;
                    }
                }
            });

            // Boundaries
            if(player.y > canvas.height) {
                gameState.lives--;
                updateUI();
                if(gameState.lives <= 0) {
                    gameOver();
                } else {
                    player.x = 100;
                    player.y = 400;
                    player.velocityX = 0;
                    player.velocityY = 0;
                }
            }

            // Camera follow
            camera.x = player.x - canvas.width / 3;
            if(camera.x < 0) camera.x = 0;

            // Update enemies
            enemies.forEach((enemy, index) => {
                if(enemy.type === 'walker') {
                    enemy.x += enemy.velocityX * enemy.direction;
                    
                    // Turn around at edges
                    let onPlatform = false;
                    platforms.forEach(platform => {
                        if(enemy.x + enemy.width > platform.x && 
                           enemy.x < platform.x + platform.width &&
                           enemy.y + enemy.height >= platform.y - 5 &&
                           enemy.y + enemy.height <= platform.y + 5) {
                            onPlatform = true;
                        }
                    });
                    
                    if(!onPlatform || enemy.x <= 0) {
                        enemy.direction *= -1;
                    }
                } else if(enemy.type === 'flying') {
                    enemy.y += enemy.velocityY;
                    if(enemy.y <= 100 || enemy.y >= 400) {
                        enemy.velocityY *= -1;
                    }
                    
                    // Follow player
                    if(Math.abs(enemy.x - player.x) < 300) {
                        enemy.x += (player.x > enemy.x ? 1 : -1);
                    }
                }

                // Enemy-player collision
                if(!player.invincible &&
                   player.x < enemy.x + enemy.width &&
                   player.x + player.width > enemy.x &&
                   player.y < enemy.y + enemy.height &&
                   player.y + player.height > enemy.y) {
                    
                    // Jump on enemy
                    if(player.velocityY > 0 && player.y + player.height - player.velocityY <= enemy.y + 10) {
                        enemies.splice(index, 1);
                        player.velocityY = -8;
                        gameState.score += 100;
                        createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 10, '#ff6b6b');
                        updateUI();
                    } else {
                        // Take damage
                        if(gameState.powerups.shield) {
                            gameState.powerups.shield = false;
                            createParticles(player.x + player.width/2, player.y + player.height/2, 15, '#4ecdc4');
                        } else {
                            gameState.lives--;
                            player.invincible = true;
                            setTimeout(() => player.invincible = false, 1000);
                            createParticles(player.x + player.width/2, player.y + player.height/2, 15, '#ff6b6b');
                        }
                        updateUI();
                        if(gameState.lives <= 0) {
                            gameOver();
                        }
                    }
                }
            });

            // Update boss
            if(boss && boss.health > 0) {
                // Boss movement
                boss.x += boss.speed;
                if(boss.x <= 100 || boss.x >= 1700) {
                    boss.speed *= -1;
                }

                // Boss attacks
                boss.attackCooldown--;
                if(boss.attackCooldown <= 0) {
                    // Shoot at player
                    const angle = Math.atan2(player.y - boss.y, player.x - boss.x);
                    projectiles.push({
                        x: boss.x + boss.width/2,
                        y: boss.y + boss.height/2,
                        width: 12,
                        height: 12,
                        velocityX: Math.cos(angle) * 5,
                        velocityY: Math.sin(angle) * 5,
                        enemy: true,
                        damage: 1
                    });
                    boss.attackCooldown = 90;
                    createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 5, '#ff0000');
                }

                // Boss-player collision
                if(!player.invincible &&
                   player.x < boss.x + boss.width &&
                   player.x + player.width > boss.x &&
                   player.y < boss.y + boss.height &&
                   player.y + player.height > boss.y) {
                    
                    if(gameState.powerups.shield) {
                        gameState.powerups.shield = false;
                    } else {
                        gameState.lives--;
                        updateUI();
                        if(gameState.lives <= 0) {
                            gameOver();
                            return;
                        }
                    }
                    player.invincible = true;
                    setTimeout(() => player.invincible = false, 1000);
                }
            }

            // Update projectiles
            projectiles.forEach((proj, index) => {
                proj.x += proj.velocityX;
                proj.y += proj.velocityY;

                // Remove off-screen projectiles
                if(proj.x < camera.x - 100 || proj.x > camera.x + canvas.width + 100) {
                    projectiles.splice(index, 1);
                    return;
                }

                // Player projectile hits
                if(!proj.enemy) {
                    enemies.forEach((enemy, eIndex) => {
                        if(proj.x < enemy.x + enemy.width &&
                           proj.x + proj.width > enemy.x &&
                           proj.y < enemy.y + enemy.height &&
                           proj.y + proj.height > enemy.y) {
                            enemies.splice(eIndex, 1);
                            projectiles.splice(index, 1);
                            gameState.score += 50;
                            createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, 8, '#ffff00');
                            updateUI();
                        }
                    });

                    // Hit boss
                    if(boss && boss.health > 0 &&
                       proj.x < boss.x + boss.width &&
                       proj.x + proj.width > boss.x &&
                       proj.y < boss.y + boss.height &&
                       proj.y + proj.height > boss.y) {
                        boss.health--;
                        projectiles.splice(index, 1);
                        gameState.score += 25;
                        createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 10, '#ff00ff');
                        updateUI();
                        
                        if(boss.health <= 0) {
                            gameState.score += 1000;
                            createParticles(boss.x + boss.width/2, boss.y + boss.height/2, 30, '#ffd700');
                            setTimeout(() => gameOver(true), 1000);
                        }
                    }
                } else {
                    // Enemy projectile hits player
                    if(!player.invincible &&
                       proj.x < player.x + player.width &&
                       proj.x + proj.width > player.x &&
                       proj.y < player.y + player.height &&
                       proj.y + proj.height > player.y) {
                        projectiles.splice(index, 1);
                        
                        if(gameState.powerups.shield) {
                            gameState.powerups.shield = false;
                        } else {
                            gameState.lives--;
                            updateUI();
                            if(gameState.lives <= 0) {
                                gameOver();
                                return;
                            }
                        }
                        player.invincible = true;
                        setTimeout(() => player.invincible = false, 1000);
                    }
                }
            });

            // Collect coins
            coins.forEach(coin => {
                if(!coin.collected &&
                   player.x < coin.x + coin.width &&
                   player.x + player.width > coin.x &&
                   player.y < coin.y + coin.height &&
                   player.y + player.height > coin.y) {
                    coin.collected = true;
                    gameState.coins++;
                    gameState.score += 10;
                    createParticles(coin.x + coin.width/2, coin.y + coin.height/2, 5, '#ffd700');
                    updateUI();
                }
                coin.animation += 0.1;
            });

            // Collect powerups
            powerups.forEach((powerup, index) => {
                if(!powerup.collected &&
                   player.x < powerup.x + 25 &&
                   player.x + player.width > powerup.x &&
                   player.y < powerup.y + 25 &&
                   player.y + player.height > powerup.y) {
                    powerup.collected = true;
                    gameState.score += 50;
                    
                    switch(powerup.type) {
                        case 'doubleJump':
                            gameState.powerups.doubleJump = true;
                            break;
                        case 'shield':
                            gameState.powerups.shield = true;
                            break;
                        case 'speedBoost':
                            gameState.powerups.speedBoost = true;
                            setTimeout(() => gameState.powerups.speedBoost = false, 10000);
                            break;
                        case 'fireRate':
                            gameState.powerups.fireRate = 2;
                            setTimeout(() => gameState.powerups.fireRate = 1, 10000);
                            break;
                    }
                    
                    createParticles(powerup.x + 12, powerup.y + 12, 15, '#ff00ff');
                    powerups.splice(index, 1);
                    updateUI();
                }
            });

            // Check goal
            if(levels[gameState.currentLevel - 1].goal) {
                const goal = levels[gameState.currentLevel - 1].goal;
                if(player.x + player.width > goal.x && player.x < goal.x + 50 &&
                   player.y + player.height > goal.y && player.y < goal.y + 100) {
                    nextLevel();
                }
            }

            // Update particles
            gameState.particles.forEach((particle, index) => {
                particle.x += particle.velocityX;
                particle.y += particle.velocityY;
                particle.velocityY += 0.2;
                particle.life--;
                
                if(particle.life <= 0) {
                    gameState.particles.splice(index, 1);
                }
            });
        }

        function draw() {
            // Background gradient
            const level = levels[gameState.currentLevel - 1];
            const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            
            if(gameState.currentLevel === 1) {
                grad.addColorStop(0, '#87CEEB');
                grad.addColorStop(0.7, '#b4d7f5');
                grad.addColorStop(1, '#e8f4f8');
            } else if(gameState.currentLevel === 2) {
                grad.addColorStop(0, '#1a0a0a');
                grad.addColorStop(0.5, '#2d1810');
                grad.addColorStop(1, '#4a2511');
            } else {
                grad.addColorStop(0, '#0a0a0a');
                grad.addColorStop(0.5, '#1a0a1a');
                grad.addColorStop(1, '#2a0a2a');
            }
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Stars (parallax)
            if(gameState.currentLevel >= 2) {
                ctx.save();
                ctx.translate(-camera.x * 0.3, 0);
                for(let i = 0; i < 50; i++) {
                    const starX = (i * 173) % (canvas.width + 500);
                    const starY = (i * 97) % canvas.height;
                    const size = i % 3 === 0 ? 2 : 1;
                    drawStar(starX, starY, size);
                }
                ctx.restore();
            }

            // Clouds/Mountains (background parallax)
            ctx.save();
            ctx.translate(-camera.x * 0.4, 0);
            
            if(gameState.currentLevel === 1) {
                // Clouds
                for(let i = 0; i < 8; i++) {
                    const cloudX = i * 250 + 50;
                    const cloudY = 60 + (i % 3) * 30;
                    drawCloud(cloudX, cloudY);
                }
                
                // Hills
                ctx.fillStyle = '#90EE90';
                ctx.beginPath();
                for(let i = 0; i < canvas.width + 600; i += 50) {
                    ctx.lineTo(i, 400 + Math.sin(i / 100) * 50);
                }
                ctx.lineTo(canvas.width + 600, canvas.height);
                ctx.lineTo(0, canvas.height);
                ctx.fill();
            } else if(gameState.currentLevel === 2) {
                // Cave background
                ctx.fillStyle = '#1a0a0a';
                for(let i = 0; i < 10; i++) {
                    const stalX = i * 150 + 50;
                    ctx.beginPath();
                    ctx.moveTo(stalX, 0);
                    ctx.lineTo(stalX - 10, 60);
                    ctx.lineTo(stalX + 10, 60);
                    ctx.fill();
                }
            }
            
            ctx.restore();

            ctx.save();
            ctx.translate(-camera.x, 0);

            // Draw platforms
            platforms.forEach(platform => {
                if(platform.breaking) {
                    ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                }
                
                if(platform.type === 'grass') {
                    drawGrassPlatform(platform.x, platform.y, platform.width, platform.height);
                } else if(platform.type === 'stone') {
                    drawStonePlatform(platform.x, platform.y, platform.width, platform.height);
                }
                
                if(platform.breakable && !platform.breaking) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                    ctx.setLineDash([]);
                }
                
                ctx.globalAlpha = 1;
            });

            // Draw hazards
            if(level.hazards) {
                level.hazards.forEach(hazard => {
                    if(hazard.type === 'lava') {
                        // Lava animation
                        const time = Date.now() / 200;
                        for(let i = 0; i < hazard.width; i += 8) {
                            const wave = Math.sin(time + i / 10) * 3;
                            drawPixel(hazard.x + i, hazard.y + wave, 8, '#ff4500');
                            drawPixel(hazard.x + i, hazard.y + wave + 8, 8, '#ff6347');
                            drawPixel(hazard.x + i, hazard.y + wave + 16, 8, '#ff7f50');
                        }
                    } else if(hazard.type === 'spikes') {
                        for(let i = 0; i < hazard.width; i += 16) {
                            const s = 4;
                            const baseY = hazard.y + 16;
                            // Spike
                            drawPixel(hazard.x + i, baseY - 12, s, '#666');
                            drawPixel(hazard.x + i + s, baseY - 8, s, '#666');
                            drawPixel(hazard.x + i, baseY - 8, s, '#888');
                            drawPixel(hazard.x + i + s*2, baseY - 4, s, '#666');
                            drawPixel(hazard.x + i + s, baseY - 4, s, '#888');
                            drawPixel(hazard.x + i, baseY, s, '#888');
                            drawPixel(hazard.x + i + s, baseY, s, '#aaa');
                            drawPixel(hazard.x + i + s*2, baseY, s, '#888');
                        }
                    }
                });
            }

            // Draw coins
            coins.forEach(coin => {
                if(!coin.collected) {
                    drawCoin(coin.x, coin.y, coin.animation);
                }
            });

            // Draw powerups
            powerups.forEach(powerup => {
                if(!powerup.collected) {
                    drawPowerup(powerup.x, powerup.y, powerup.type, Date.now() / 200);
                }
            });

            // Draw checkpoint
            if(checkpoints.length > 0) {
                const cp = checkpoints[0];
                const s = 6;
                // Flag pole
                for(let i = 0; i < 11; i++) {
                    drawPixel(cp.x, cp.y + i * s, s, '#654321');
                }
                // Flag
                const flag = [
                    [1,1,1,1],
                    [1,1,1,0],
                    [1,1,0,0],
                    [1,0,0,0]
                ];
                for(let row = 0; row < 4; row++) {
                    for(let col = 0; col < 4; col++) {
                        if(flag[row][col]) {
                            drawPixel(cp.x + s + col*s, cp.y + row*s, s, '#00ff00');
                        }
                    }
                }
            }

            // Draw goal
            if(level.goal) {
                const goal = level.goal;
                const s = 8;
                // Castle/Goal
                for(let i = 0; i < 6; i++) {
                    for(let j = 0; j < 12; j++) {
                        const color = (i + j) % 2 === 0 ? '#ffd700' : '#ffed4e';
                        drawPixel(goal.x + i*s, goal.y + j*s, s, color);
                    }
                }
                // Flag
                [[2,0],[3,0],[2,1],[3,1],[4,1],[2,2],[3,2],[4,2],[5,2]].forEach(p => {
                    drawPixel(goal.x + p[0]*s, goal.y + p[1]*s, s, '#ff0000');
                });
            }

            // Draw enemies
            enemies.forEach(enemy => {
                if(enemy.type === 'walker') {
                    drawEnemyWalker(enemy.x, enemy.y, Date.now() / 200);
                } else if(enemy.type === 'flying') {
                    drawEnemyFlying(enemy.x, enemy.y, Date.now() / 100);
                }
            });

            // Draw boss
            if(boss && boss.health > 0) {
                drawBoss(boss.x, boss.y, Date.now() / 100);
                
                // Health bar
                const barWidth = 200;
                const barHeight = 20;
                const barX = boss.x + (boss.width * 5 - barWidth) / 2;
                const barY = boss.y - 40;
                
                // Bar background
                ctx.fillStyle = '#000';
                ctx.fillRect(barX - 4, barY - 4, barWidth + 8, barHeight + 8);
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Health
                const healthPercent = boss.health / boss.maxHealth;
                const healthGrad = ctx.createLinearGradient(barX, 0, barX + barWidth * healthPercent, 0);
                healthGrad.addColorStop(0, '#ff0000');
                healthGrad.addColorStop(1, '#ff6b6b');
                ctx.fillStyle = healthGrad;
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                // Bar border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }

            // Draw projectiles
            projectiles.forEach(proj => {
                drawProjectile(proj.x, proj.y, proj.enemy);
            });

            // Draw player
            if(player.invincible) {
                ctx.globalAlpha = Math.sin(Date.now() / 50) * 0.5 + 0.5;
            }
            
            if(gameState.powerups.shield) {
                // Shield effect
                const shieldGrad = ctx.createRadialGradient(
                    player.x + 16, player.y + 16, 5,
                    player.x + 16, player.y + 16, 35
                );
                shieldGrad.addColorStop(0, 'rgba(78, 205, 196, 0.3)');
                shieldGrad.addColorStop(0.5, 'rgba(78, 205, 196, 0.6)');
                shieldGrad.addColorStop(1, 'rgba(78, 205, 196, 0)');
                ctx.fillStyle = shieldGrad;
                ctx.fillRect(player.x - 20, player.y - 20, 72, 72);
                
                // Shield hexagons
                const sides = 6;
                const radius = 30 + Math.sin(Date.now() / 100) * 3;
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for(let i = 0; i <= sides; i++) {
                    const angle = (Math.PI * 2 / sides) * i;
                    const x = player.x + 16 + Math.cos(angle) * radius;
                    const y = player.y + 16 + Math.sin(angle) * radius;
                    if(i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            const walkSpeed = Math.abs(player.velocityX);
            const animSpeed = walkSpeed > 0.1 ? player.animation : 0;
            drawPlayerSprite(player.x, player.y, player.direction, animSpeed, player.crouching);
            
            ctx.globalAlpha = 1;

            // Draw particles
            gameState.particles.forEach(particle => {
                ctx.globalAlpha = particle.life / 30;
                drawParticle(particle.x, particle.y, particle.size, particle.color);
            });
            ctx.globalAlpha = 1;

            // Dash trail effect
            if(player.dashCooldown > 50) {
                const trailAlpha = (player.dashCooldown - 50) / 10;
                ctx.globalAlpha = trailAlpha * 0.3;
                drawPlayerSprite(
                    player.x - player.velocityX * 2,
                    player.y,
                    player.direction,
                    animSpeed,
                    player.crouching
                );
                ctx.globalAlpha = 1;
            }

            ctx.restore();
        }

        function drawCloud(x, y) {
            const s = 8;
            const colors = ['#ffffff', '#f0f0f0', '#e0e0e0'];
            
            // Cloud pixels
            [
                [0,0,0,1,1,1,1,0,0,0],
                [0,1,1,1,1,1,1,1,1,0],
                [1,1,2,2,1,1,2,2,1,1],
                [1,2,2,2,2,2,2,2,2,1],
                [1,1,2,2,2,2,2,2,1,1],
                [0,1,1,1,1,1,1,1,1,0],
                [0,0,1,1,1,1,1,1,0,0]
            ].forEach((row, j) => {
                row.forEach((pixel, i) => {
                    if(pixel > 0) {
                        drawPixel(x + i * s, y + j * s, s, colors[pixel - 1]);
                    }
                });
            });
        }

        function gameLoop() {
            update();
            draw();
            if(gameState.running) {
                requestAnimationFrame(gameLoop);
            }
        }
    </script>
</body>
</html>